<!doctype html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <link rel="stylesheet" href="style.css">
    <title>Layer Transport</title>
</head>

<body>
    <header>
        <nav class="navbar navbar-expand-lg navbar-light bg-transparant">
            <div class="container">
                <!--class container memberi margin right dan left pada navbar-->
                <!-- Just an image -->
                <nav class="navbar navbar-light bg-transparant">
                    <h1>DeaWahsaSaputri</h1>
                </nav>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
  <span class="navbar-toggler-icon"></span>
</button>
                <div class="collapse navbar-collapse" id="navbarNav">
                    <ul class="navbar-nav ml-auto">
                        <!--ml = margin left-->
                        <li class="nav-item active">
                            <a class="nav-link text-warning font-weight-bold " href="home.html">Home <span class="sr-only">(current)</span></a>
                        </li>
                        <li class="nav-item dropdown">
                            <a class="nav-link text-warning font-weight-bold dropdown-toggle" href="#" id="navbarDropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
              Theory
            </a>
                            <div class="dropdown-menu" aria-labelledby="navbarDropdownMenuLink">
                                <a class="dropdown-item" href="dea.html">UDP</a>
                                <a class="dropdown-item" href="bulan.html">TCP</a>
                                
                            </div>
                        </li>
                        

                    </ul>
                </div>
            </div>
        </nav>
    </header>

    <div class="jumbotron">
        <div class="container">
            <h1 class="display-4">LAYER TRANSPORT <br><span class="font-weight-bold"></br>TCP (TRANSMISSION CONTROL PROTOCOL)</span></h1>
        </div>
    </div>

    <section id="newsletterr">
        <div class="container">
            <h1>TCP</h1>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <p><b>Model referensi TCP/IP</b></p>
                <h1>
        </div>
    </section>

    <section id="boxesr">
        <div class="container">
            <div class="box">
                <img src="img/TCP.png">
            </div>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <br>Pada saat kita memulai langkah ke dalam ilmu jaringan komputer, hal yang pertama kali kita pelajari biasanya adalah TCP/IP. Agar komunikasi dan pertukaran informasi bisa terjalin dengan baik, dibutuhkan bahasa sama. Walaupun merek
                host jaringan tersebut berbeda - beda, host masih bisa berkomunikasi dengan host lain karena menggunakan standart komunikasi yang sama, yakni TCP/IP. Protokol internet pertama kali dirancang pada tahun 1980-an. Akan tetapi di tahun 1990-an
                dimana internet semakin populer dan host yang semakin banyak, mulai bemunculan protokol yang hanya bisa digunakan oleh kalangan tertentu, atau protokol yang dibuat oleh pabrik tertentu yang belum tentu kompatibel dengan protokol lain dari
                pabrik yang lain pula. Sehingga pada akhirnya badan International Standart Organization (ISO) membuat standarisasi protokol yang saat ini dikenal dengan protokol model Open System Interconnection atau disingkat OSI. Model OSI ini manjadi
                referensi dan konsep dasar teori tentang cara kerja sebuah protokol. Dalam perkembangannya TCP/IP digunakan sebagai standart de facto. Ketika ISO (International Standart Organization) membuat standarisasi protokol, maka terciptalah sebuah
                standar model referensi yang berisi cara kerja protokol. Model referensi yang kemudian disebut dengan Open System Interconnection (OSI). Berdasarkan dokumen rekomendasi X.200, standart OSI ini memiliki 7 layer. Tiap layer ini memiliki
                definisi fungsi yang berbeda.</br>
                <br>TCP/IP adalah singkatan dari Transmission Control Protocol/Internet Protocol. TCP/IP merupakan standar komunikasi data yang digunakan untuk dalam proses tukar-menukar data dari satu komputer ke komputer lain pada jaringan Internet.
                Karena berupa kumpulan protokol (protocol suite) maka Protokol ini tidaklah mampu berdiri sendiri. TCP/IP merupakan yang paling banyak dipakai pada saat ini. Data tersebut diimplementasikan dalam bentuk software atau perangkat lunak pada
                sistem operasi. Istilah yang diberikan kepada perangkat lunak tersebut yaitu TCP/ IP stack.</br>
            </h1>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <p><b>Prinsip kerja TCP:</b></p>
                <br>TCP mempunyai prinsip kerja seperti "virtual circuit" pada jaringan telepon. TCP lebih mementingkan tata-cara dan keandalan dalam pengiriman data antara dua komputer dalam jaringan. TCP tidak perduli dengan apa-apa yang dikerjakan
                oleh IP, yang penting adalah hubungan komunikasi antara dua komputer berjalan dengan baik. Dalam hal ini, TCP mengatur bagaimana cara membuka hubungan komunikasi, jenis aplikasi apa yang akan dilakukan dalam komunikasi tersebut (misalnya
                mengirim e-mail, transfer file dsb.) Di samping itu, juga mendeteksi dan mengoreksi jika ada kesalahan data. TCP mengatur seluruh proses koneksi antara satu komputer dengan komputer yang lain dalam sebuah jaringan komputer.<br>
                <br>Berbeda dengan IP yang mengandalkan mekanisme connectionless pada TCP mekanisme hubungan adalah connection oriented. Dalam hal ini, hubungan secara logik akan dibangun oleh TCP antara satu komputer dengan komputer yang lain. Dalam
                waktu yang ditentukan komputer yang sedang berhubungan harus mengirimkan data atau acknowledge agar hubungan tetap berlangsung. Jika hal ini tidak sanggup dilakukan maka dapat diasumsikan bahwa komputer yang sedang berhubungan dengan kita
                mengalami gangguan dan hubungan secara logik dapat diputus.</br>
                <br>TCP mengatur multiplexing dari data yang dikirim/diterima oleh sebuah komputer. Adanya identifikasi pada TCP header memungkinkan multiplexing dilakukan. Hal ini memungkinkan sebuah komputer melakukan beberapa hubungan TCP secara logik.
                Bentuk hubungan adalah full duplex, hal ini memungkinkan dua buah komputer saling berbicara dalam waktu bersamaan tanpa harus bergantian menggunakan kanal komunikasi. Untuk mengatasi saturasi (congestion) pada kanal komunikasi, pada header
                TCP dilengkapi informasi tentang flow control.</br>
                <br>Hal yang cukup penting untuk dipahami pada TCP adalah port number. Port number menentukan servis yang dilakukan oleh program aplikasi diatas TCP. Nomor-nomor ini telah ditentukan oleh Network Information Center dalam Request For Comment
                (RFC) 1010 [10]. Sebagai contoh untuk aplikasi File Transfer Protokol (FTP) diatas transport layer TCP digunakan port nomor 20 dan masih banyak lagi.</br>
                <br>Prinsip kerja dari TCP berdasarkan prinsip client-server. Server adalah program pada komputer yang secara pasif akan mendengarkan (listen) nomor port yang telah ditentukan pada TCP. Sedang client adalah program yang secara aktif akan
                membuka hubungan TCP ke komputer server untuk meminta servis yang dibutuhkan.</br>
            </h1>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <p><b>Fungsi Layer Transport</b></p>
                <br> 1. Menerima data dari session layer</br>
                <br> 2. Memecah data menjadi bagian – bagian yang lebih kecil</br>
                <br> 3. Meneruskan data ke network layer</br>
                <br> 4. Memastikan bahwa semua data yang melewatinya dapat tiba di sisi lainnya dengan tepat</br>
                <br> 5. Mengirim segment dari satu host ke host yang lain</br>
                <br> 6. Memastikan realibilitas data</br>
                <br> 7. Mengatur lalu lintas dari sebuah jaringan</br>
            </h1>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <p><b>Mengapa Model Referensi dibuat Berlayer?</b></p>
                <br>Lapisan-Lapisan pada OSI Layer dibuat dengan tujuan agar setiap paket data dalam sebuah jaringan bisa melewati layer tersebut sebelum pada akhirnya bisa saling terkoneksi. Model OSI Layer ini beroperasi dengan satu prinsip dasar, yaitu
                setiap layer menangani pekerjaan spesifik, dan kemudian meneruskan data ke layer berikutnya sebelum akhirnya terkoneksi satu sama lain. Maka dari itu, setiap layer memiliki fungsi yang berbeda.</br>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <p><b>Struktur segmen TCP dan fungsi masing-masing fieldnya</b></p>
                <h1>
        </div>
    </section>

    <section id="boxesr">
        <div class="container">
            <div class="box">
                <img src="img/struktur segmen TCP.jpg">
            </div>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <br>1. Source Port. Source Port memiliki ukuran 2 byte dan mengindikasikan sumber protokol lapisan aplikasi yang mengirimkan segmen TCP yang bersangkutan. Gabungan antara field Source IP Address dalam header IPdan field Source Port dalam
                field header TCP disebut juga sebagai socketsumber, yang berarti sebuah alamat global dari mana segmen dikirimkan. Lihat juga Port TCP.</br>
                <br>2. Destination Port. Destination Port memiliki ukuran 2 byte (16 bit) dan mengindikasikan tujuan protokol lapisan aplikasi yang menerima segmen yang bersangkutan. Gabungan antara field Destination IP Address dalam header IP dan field
                Destination Port dalam field header TCP disebut juga sebagai sockettujuan, yang berarti sebuah alamat global ke mana segmen akan dikirimkan.</br>
                <br>3. Sequence Number. Sequence Number memiliki ukuran 4 byte (32 bit) dan mengindikasikan nomor urut dari oktet pertama dari data di dalam sebuah segmen TCP yang hendak dikirimkan. Field ini harus selalu diset, meskipun tidak ada data
                (payload) dalam segmen. Ketika memulai sebuah sesi koneksi TCP, segmen dengan flag SYN (Synchronization) diset ke nilai 1, field ini akan berisi nilai Initial Sequence Number (ISN). Hal ini berarti, oktet pertama dalam aliran byte (byte
                stream) dalam koneksi adalah ISN+1.</br>
                <br>4. Acknowledgment Number. Acknowledgment Number memiliki ukuran 4 byte (32 bit) dan mengindikasikan nomor urut dari oktet selanjutnya dalam aliran byte yang diharapkan oleh untuk diterima oleh pengirim dari si penerima pada pengiriman
                selanjutnya. Acknowledgment number sangat dipentingkan bagi segmen-segmen TCP dengan flag ACK diset ke nilai 1.</br>
                <br>5. Data Offset. Data Offset memiliki ukuran 4 bit dan mengindikasikan di mana data dalam segmen TCP dimulai. Field ini juga dapat berarti ukuran dari header TCP. Seperti halnya field Header Length dalam header IP, field ini merupakan
                angka dari word 32-bit dalam header TCP. Untuk sebuah segmen TCP terkecil (di mana tidak ada opsi TCP tambahan), field ini diatur ke nilai 0×5, yang berarti data dalam segmen TCP dimulai dari oktet ke 20 dilihat dari permulaan segmen TCP.
                Jika field Data Offset diset ke nilai maksimumnya (24=16) yakni 15, header TCP dengan ukuran terbesar dapat memiliki panjang hingga 60 byte.</br>
                <br>6. Reserved. Reserved memiliki ukuran 6 bit dan direservasikan untuk digunakan pada masa depan. Pengirim segmen TCP akan mengeset bit-bit ini ke dalam nilai 0.</br>
                <br>7. Flags. Flags memiliki ukuran 6 bit dan mengindikasikan flag-flag TCP yang memang ada enam jumlahnya, yang terdiri atas: URG (Urgent), ACK (Acknowledgment), PSH (Push), RST (Reset), SYN (Synchronize), dan FIN (Finish).</br>
                <br>8. Window. Window memiliki ukuran 2 byte (16 bit) dan mengindikasikan jumlah byte yang tersedia yang dimiliki oleh buffer host penerima segmen yang bersangkutan. Buffer ini disebut sebagai Receive Buffer, digunakan untuk menyimpan
                byte stream yang datang. Dengan mengimbuhkan ukuran window ke setiap segmen, penerima segmen TCP memberitahukan kepada pengirim segmen berapa banyak data yang dapat dikirimkan dan disangga dengan sukses. Hal ini dilakukan agar si pengirim
                segmen tidak mengirimkan data lebih banyak dibandingkan ukuran Receive Buffer. Jika tidak ada tempat lagi di dalam Receive buffer, nilai dari field ini adalah 0. Dengan nilai 0, maka si pengirim tidak akan dapat mengirimkan segmen lagi
                ke penerima hingga nilai field ini berubah (bukan 0). Tujuan hal ini adalah untuk mengatur lalu lintas data atau flow control.</br>
                <br>9. Checksum. Checksum memiliki ukuran 2 byte (16 bit) dan mampu melakukan pengecekan integritas segmen TCP (header-nya dan payload-nya). Nilai field Checksum akan diatur ke nilai 0 selama proses kalkulasi checksum.</br>
                <br>10. Urgent Pointer. Urgent Pointer memiliki ukuran 2 byte (16 bit) dan menandakan lokasi data yang dianggap “urgent” dalam segmen.Urgent Pointer.</br>
                <br>11. Options. Options memiliki ukuran 4 byte (32 bit) dan berfungsi sebagai penampung beberapa opsi tambahan TCP. Setiap opsi TCP akan memakan ruangan 32 bit, sehingga ukuran header TCP dapat diindikasikan dengan menggunakan field Data
                offset.
                </br>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <p><b>Proses Flow Control</b></p>
                <br>Untuk mencegah data terlalu banyak dikirimkan pada satu waktu, yang akhirnya membuat “macet” jaringan internetwork IP, TCP mengimplementasikan layanan flow control yang dimiliki oleh pihak pengirim yang secara terus menerus memantau
                dan membatasi jumlah data yang dikirimkan pada satu waktu. Untuk mencegah pihak penerima untuk memperoleh data yang tidak dapat disangganya (buffer), TCP juga mengimplementasikan flow control dalam pihak penerima, yang mengindikasikan
                jumlah buffer yang masih tersedia dalam pihak penerima.
                </br>
                <br>Flow control membantu reliability proses transmisi dengan cara menyesuaikan kecepatan efektif untuk aliran data antara 2 mesin. Ketika pengirim (source) diberi tahu bahwa sejumlah data telah diterima, maka source dapat meningkatkan
                jumlah data untuk session tersebut.
                </br>
                <br>Window size adalah salah satu field header TCP yang menentukan jumlah data yang dapat dikirimkan oleh source tanpa harus menunggu adanya acknowledgement dari penerima. TCP akan memilih kecepatan transmisi data semaksimal mungkin yang
                dapat di dukung oleh network dan device dan proses retransmisi bisa dikurangi seminimal mungkin.</br>
                <br>Salah satu metode flow control adalah dengan menggunakan dynamic window size. Caranya adalah dengan mengubah-ubah nilai window size pada header TCP. Host penerima mengirim nilai window size yang bisa ditampung dalam satu session kepada
                pengirim. Ketika penerima ingin menurunkan kecepatan komunikasi karena terbatasnya buffer memori atau hal lain, maka dia akan mengirim nilai window size yang lebih kecil. Setelah beberapa kali transmisi tanpa ada data yang hilang atau
                buffer memori berlebih, penerima perlahan menaikkan nilai window size sehingga mengurangi jumlah acknowledgement yang harus dikirimkan. Nilai window size akan terus naik sampai ada data yang hilang atau alasan lain.</br>
            </h1>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <p><b>Mekanisme pembukaan dan penutupan hubungan komunikasi</b></p>
                <br>Connection establish antara host pengirim dan host tujuan dilakukan dengan menjalankan Three Way Handshake. Three-way Handshake adalah proses pembuatan koneksi TCP yang bertujuan melakukan sinkronisasi terhadap nomor urut dan nomor
                acknowledgement yang dikirimkan oleh kedua host dan saling bertukar ukuran TCP Window. Three-way Handshake ini merupakan suatu metode yang digunakan untuk membangun TCP koneksi atau mengakhiri TCP koneksi. Three-way Handshake diantaranya
                adalah "SYN-ACK SYN-ACK".</br>
            </h1>
        </div>
    </section>

    <section id="boxesr">
        <div class="container">
            <div class="box">
                <img src="img/TCP state.png">
            </div>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <br>Connection establish antara host pengirim dan host tujuan dilakukan dengan menjalankan Three Way Handshake. Three-way Handshake adalah proses pembuatan koneksi TCP yang bertujuan melakukan sinkronisasi terhadap nomor urut dan nomor
                acknowledgement yang dikirimkan oleh kedua host dan saling bertukar ukuran TCP Window. Three-way Handshake ini merupakan suatu metode yang digunakan untuk membangun TCP koneksi atau mengakhiri TCP koneksi. Three-way Handshake diantaranya
                adalah "SYN-ACK SYN-ACK".</br>
                <br>Prosesnya dapat dijelaskan sebagai berikut:</br>
                <br>1. Host pertama (yang ingin membuat koneksi) akan mengirimkan sebuah segmen TCP dengan flag SYN dan diaktifkan kepada host kedua (yang akan diajak komunikasi).
                <br>2. Host kedua akan meresponnya dengan mengirimkan segmen dengan acknowledgement dan juga SYN kepada host pertama.
                <br>3. Host pertama selanjutnya akan mulai saling bertukar data dengan host kedua.</br>
                <br>TCP menggunakan proses jabat tangan yang sama untuk mengakhiri koneksi yang dibuat. Hal ini menjamin dua host yang sedang terkoneksi tersebut telah menyelesaikan proses transmisi data dan semua data yang ditransmisikan telah diterima
                dengan baik. Itulah sebabnya, mengapa TCP disebut dengan koneksi yang reliable</br>
            </h1>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <p><b>Bagaimana TCP mengatasi kongesti (kemacetan dalam jaringan)?</b></p>
                <br>Kebijakan umum TCP untuk penanganan kemacetan didasarkan pada tiga fase: start lambat, penghindaran kemacetan, dan deteksi kemacetan. Pada fase lambat-start, pengirim mulai dengan tingkat penularan sangat lambat, tetapi meningkatkan
                laju cepat untuk mencapai ambang pintu. Ketika ambang batas tersebut tercapai, kecepatan data dikurangi untuk menghindari kemacetan. Akhirnya jika kemacetan terdeteksi, pengirim akan kembali ke awal lambat atau menghindari kemacetan fase
                didasarkan pada bagaimana kemacetan terdeteksi. Mulai lambat: Eksponensial Meningkatkan Salah satu algoritma yang digunakan dalam TCP pengendalian kemacetan ini disebut mulai lambat. Algoritma ini didasarkan pada gagasan bahwa ukuran kemacetan
                jendela (cwnd) dimulai dengan satu ukuran segmen maksimum (MSS). MSS ini ditentukan selama pembentukan koneksi dengan menggunakan pilihan dari nama yang sama. Ukuran jendela akan bertambah satu setiap kali MSS pengakuan diterima. Sebagai
                nama menyiratkan, jendela mulai perlahan, tetapi tumbuh secara eksponensial.</br>
                <br>Penghindaran Kemacetan : Meningkatkan aditif jika kita dengan algoritma lambat-start, ukuran jendela kemacetan meningkat secara eksponensial. Untuk menghindari kemacetan sebelum hal itu terjadi, seseorang harus memperlambat pertumbuhan
                yang eksponensial. TCP mendefinisikan algoritma-lain disebut algoritma kendali menghindari kemacetan, yang mengalami peningkatan aditif bukan salah satu yang eksponensial. Bila ukuran jendela kemacetan mencapai start-lambat ambang, berhenti
                fase lambat mulai dan tahap aditif dimulai.
                </br>
                <br>Kemacetan Deteksi : multiplikatif Penurunan jika kemacetan terjadi, kemacetan ukuran jendela harus dikurangi. Satu-satunya cara pengirim dapat menebak kemacetan yang memiliki terjadi adalah dengan kebutuhan untuk Retransmisi segmen.
                Namun, retransmissi dapat terjadi pada salah satu dari dua kasus: ketika suatu kali waktu keluar atau ketika tiga ACK diterima. Dalam kedua kasus, ukuran ambang terjatuh ke satu-setengah, turun perkalian.</br>
            </h1>
        </div>
    </section>


    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

</body>

</html>