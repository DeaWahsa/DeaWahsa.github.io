<!doctype html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <link rel="stylesheet" href="style.css">
    <title>Pemodelan Protokol Komunikasi Layer</title>
</head>

<body>
    <header>
        <nav class="navbar navbar-expand-lg navbar-light bg-transparant">
            <div class="container">
                <!--class container memberi margin right dan left pada navbar-->
                <!-- Just an image -->
                <nav class="navbar navbar-light bg-transparant">
                    <h1>DeaWahsaSaputri</h1>
                </nav>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
  <span class="navbar-toggler-icon"></span>
</button>
                <div class="collapse navbar-collapse" id="navbarNav">
                    <ul class="navbar-nav ml-auto">
                        <!--ml = margin left-->
                        <li class="nav-item active">
                            <a class="nav-link text-warning font-weight-bold " href="home.html">Home <span class="sr-only">(current)</span></a>
                        </li>
                        <li class="nav-item dropdown">
                            <a class="nav-link text-warning font-weight-bold dropdown-toggle" href="#" id="navbarDropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
              Theory
            </a>
                            <div class="dropdown-menu" aria-labelledby="navbarDropdownMenuLink">
                                <a class="dropdown-item" href="dea.html">UDP</a>
                                <a class="dropdown-item" href="wahsa.html">TCP</a>
                                <a class="dropdown-item" href="FSM.html">FSM</a>
                                
                            </div>
                        </li>
                        

                    </ul>
                </div>
            </div>
        </nav>
    </header>

    <div class="jumbotron">
        <div class="container">
            <h1 class="display-4">Pemodelan Protokol Komunikasi Layer Transport Menggunakan Finite State Machine <br><span class="font-weight-bold"></br>
        </div>
    </div>

    <section id="newsletterr">
        <div class="container">
            <h1>Finite State MAchine(FSM)</h1>
        </div>
    </section>


    <section id="letterr">
        <div class: "container">
            <h1>
                <br>Finite State Machine (FSM) adalah sebuah metodologi perancangan sistem kontrol yang menggambarkan tingkah laku atau prinsip 
                erja sistem dengan menggunakan tiga hal berikut: State (Keadaan), Event (kejadian) dan action (aksi). Pada satu saat dalam 
                periode waktu yang cukup signifikan, sistem akan berada pada salah satu state yang aktif. Sistem dapat beralih atau bertransisi 
                menuju state lain jika mendapatkan masukan atau event tertentu, baik yang berasal dari perangkat luar atau komponen dalam 
                sistemnya itu sendiri. Transisi keadaan ini umumnya juga disertai oleh aksi yang dilakukan oleh sistem ketika menanggapi masukan 
                yang terjadi. Aksi yang dilakukan tersebut dapat berupa aksi yang sederhana atau melibatkan rangkaian proses yang relatif kompleks 
                (Setiawan : 2006).</br>
            </h1>
        </div>
    </section>

    <section id="boxesr">
        <div class="container">
            <div class="box">
                <img src="img/fsm.jpg">
            </div>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <p><b>Finite State Diagram terdiri dari:</b></p>
                <br>1. Lingkaran menyatakan state
                <br>Lingkaran diberi label sesuai dengan nama state tersebut.</br>
                <br>Adapun pembagian lingkaran adalah:
                <br>– Lingkaran bergaris tunggal berarti state sementara
                <br>– Lingkaran bergaris ganda berarti state akhir</br>
                <br>2. Anak Panah menyatakan transisi yang terjadi
                <br>Label di anak panah menyatakan simbol yang membuat transisi dari 1 state ke state lain
                <br>1 anak panah diberi label start untuk menyatakan awal mula transisi dilakukan.</br>
                <br>Diagram tersebut memperlihatkan FSM dengan dua buah state (S0 dan S1) dan dua buah input (e1 dan e2) serta dua buah aksi (a1 dan a2) output
                    yang berbeda : seperti terlihat pada gambar, ketika sistem mulai dihidupkan, sistem akan bertransisi menuju state0, pada keadaan ini sistem 
                    akan menghasilkan Action2 jika terjadi masukan Event2, sedangkan jika terjadi Event1 maka Action1 akan dieksekusi kemudian sistem 
                    selanjutnya bertransisi ke keadaan State1 dan seterusnya.</br>
                <br>Secara formal FSM dinyatakan oleh 5 tupel atau M=(Q, ∑, δ, S, F),  (Utdirartama, 2001) dimana:</br>
                <br>Q = himpunan state/kedudukan</br>
                <br>∑ = himpunan symbol input/masukan/abjad<br>
                <br>δ = fungsi transisi<br>
                <br>S = state awal/ kedudukan awal (initial state), S Q</br>
                <br>F = himpunan state akhir, F Q</br>
                <br>FSM terdiri dari dua jenis, yaitu FSM ber-output dan FSM tidak ber-output. FSM tidak ber-output digunakan untuk pengenalan bahasa dalam 
                    komputer, dengan input yang dimasukkan akan diperoleh apakah input tersebut dikenal oleh bahasa komputer atau tidak. Salah satu penggunaan 
                    FSM tidak ber-output adalah program compiler, yaitu program untuk memeriksa apakah perintah yang digunakan pengguna benar atau salah. 
                    Sementara untuk FSM ber-output digunakan untuk merancang mesin atau sistem (Zen, 2008).</br>
                <br><p><b>Ada dua metode utama untuk memperlakukan FSM untuk menghasilkan output, yaitu:</b></p>
                <br>1. Moore State Machine</br>
                <br>Moore Machine adalah tipe dari FSM dimana output dihasilkan dari state. Pada gambar diatas mencontohkan dimana state mendefenisikan apa 
                    yang harus dilakukan (Brownlee, 2010). Keluaran pada Moore Machine diasosiasikan sebagai state (Hariyanto, 2004). Dan pada penelitian ini, 
                    penulis menggunakan Moore Machine.</br>
                <br>2. Mearly State Machine</br>
                <br>Mearly Machine berbeda dengan Moore Machine dimana keluarannya merupakan hasil dari transisi antar state (Brownlee, 2010). Keluaran pada 
                    Mearly Machine diasosiasikan sebagai transisi (Hariyanto, 2004)</br>
                <br><p><b>Kelebihan dan Kekurangan FSM:</b></p>
                <br>A. Kelebihan</br>
                <br>1. Sederhana, sehingga mudah diimplementasikan
                <br>2. Bisa diprediksi responnya
                <br>3. Komputasi ringan
                <br>4. Relatif fleksibel
                <br>5. Merupakan metode AI lama yang bisa digunakan pada berbagai sistem
                <br>6. Mudah ditransfer dari abstrak menjadi kode program</br>
                <br>B. Kekurangan</br>
                <br>1. Karena sifatnya bisa diprediksi, maka implementasi pada game kurang disukai
                <br>2. Implementasi pada sistem yang lebih besar lebih sulit karena pengaturan dan pemeliharaannya jadi kompleks
                <br>3. Sebaiknya hanya digunakan pada sistem dimana sifat sistem bisa didekomposisi menjadi state.
                <br>4. Kondisi untuk transisi state adalah tetap</br>
                <br><p><b>Teknik Pemodelan FSM</b></p>
                <br>Finite State Machine bukanlah metode yang baru. FSM sudah lama ada dan konsep dekomposisi biasanya sudah dipahami dan sering 
                    digunakan oleh orang-orang yang memiliki pengalaman dalam membuat program komputer atau desain program komputer. Ada beberapa 
                    teknik pemodelan abstrak yang bisa digunakan untuk membantu defenisi atau pemahaman dan desain dari FSM, mayoritas teknik ini 
                    berasal dari disiplin ilmu desain atau matematika (Lee: 1998).</br>
                <br>1. Diagram Transisi State Juga dikenal sebagai Diagram Gelembung (Bubble Diagram). Menunjukkan relasi antara state dengan 
                    input yang menyebabkan transisi state.</br>
                <br>2. Diagram Pengambilan Keputusan State-Aksi. Diagram Alir sederhana dengan tambahan gelembung yang menunjukkan penungguan 
                    terhadap input.</br>
                <br>3. Diagram Grafik State Salah satu bentuk dari notasi UML yang berfungsi untuk menunjukkan sifat individu dari objek sebagai 
                    nomor state dan transisi dari state tersebut.</br>
                <br>4. Analisa Hirarki Perintah Meskipun tidak seperti state, ini merupakan teknik dekomposisi perintah yang melihat dari sudut 
                    pandang bagaimana caranya perintah dibagi jadi sub perintah dan urut sesuai urutan kejadiannya.</br>
                <br><p><b>Bentuk Implementasi</b></p>
                <br>Ada beberapa bentuk FSM, diantaranya:</br>
                <br>1. Naive Approach</br>
                <br>Menggunakan conditional statement (if-else atau switch-case) tanpa memecah object menjadi object2x yang lebih kecil sesuai 
                    state nya. Untuk agen yang cuma punya state yang sedikit, metode ini masih memungkinkan. Tapi kalau sudah kompleks, penggunaan 
                    metode ini jelas tidak dianjurkan, karena akan membentuk ‘spaghetti code’ dan monolithic conditional statement. Selain itu juga 
                    tidak scalable, tidak fleksibel, dan proses debugging menjadir lebih rumit.</br>
                <br>2. State Transition Table</br>
                <br>Bentuk ini sudah mengimplementasikan State Pattern, dengan menempatkan transition logic di context. Bentuk ini juga sering 
                    disebut sebagai Classic FSM.</br>
                <br>3. Embedded Rules</br>
                <br>Bentuk ini adalah kebalikan dari bentuk Classical Approach, yang berarti state transition didefinisikan di state itu sendiri. 
                    Dan sama dengan Classical Approach, bentuk ini juga akan menawarkan fleksibilitas dan skalabilitas yang baik, namun dengan efek 
                    samping agak sulit untuk di-mantain karena aturan2x transisi diletakkan di state sehingga ketika terjadi penambahan atau pengurangan
                    state, maka harus dilakukan update juga terhadap state2x yang terkait.
            </h1>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <p><b>Pemodelan Reliable Data Transfer Protokol Pada Layer Transport dengan FSM</b></p>
                <br>Tujuan utama adanya lapisan pada jaringan internet adalah menyediakan layanan dan upaya terbaik dalam hal jaminan pengiriman 
                    paket hingga tiba di tujuan. Permasalahan yang mendasari adanya lapisan jaringan internet adalah karena setiap paket yang 
                    diarahkan secara individu memungkinkan adanya kerusakan. Untuk layanan yang berbasis Connection Oriented yang disediakan TCP, 
                    perlu memiliki protokol yang disebut Reliable Data Transfer (RDT) yang memastikan bahwa semua paket yang dikirim bisa sampai 
                    pada tujuan hinggal ke lapisan teratas (Application Layer).</br>
                <br>Secara dasar, RDT menggunakan protokol Stop-and-Wait. Cara kerjanya adalah setelah mengirim setiap paket, sender akan 
                    berhenti mengirim dan menunggu feedback dari penerima yang menandakan bahwa paket telah sampai tujuan. Namun, karena alasan 
                    jarak yang jauh, muncul berbagai versi update yang ada di RDT.</br>
                <br>Ada beberapa versi dari RDT</br>
                <p><b><br>1. rdt1.0 = RDT over a Perfectly Reliable Channel</br></b><p>
                <br>Versi ini merupakan versi dasar dari RDT, dimana ketika Sender mengirim sebuah paket data, maka paket data selanjutnya akan 
                    dikirim jika Receiver telah menerima paket bahwa paket data yang telah dirikirim sudah diterima. Kelemahan rdt 1.0 yaitu Tidak 
                    ada pengecekan bit eror pada setiap paket.</br>
                <br>Dari Sisi Sender:</br>
                <br>1. menunggu panggilan dari atas (layer aplikasi)
                <br>2. ketika ada perintah maka jalankan fungsi packet=make_pkt  
                <br>3. paket dikirimkan dengan memakai fungsi udt_send(packet)</br>
            </h1>
        </div>
    </section>

    <section id="boxesrr">
        <div class="container">
            <div class="box">
                <img src="img/rdt1.png">
            </div>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <br>Dari sisi Receiver:</br>
                <br>1. Pertama, fungsi rdt_rcv yaitu menunggu panggilan dari bawah(layer data link)   
                <br>2. Ketika ada sinyal maka dia menerima paket   
                <br>3. Selanjutnya akan dijalankan fungsi extract yaitu mengekstrak paket data   
                <br>4. Selanjutnya dikirim ke layer aplikasi(di sisi penerima). 
            </h1>
        </div>
    </section>

    <section id="boxesrr">
        <div class="container">
            <div class="box">
                <img src="img/rdt1a.png">
            </div>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <p><b><br>2. rdt2.0 = RDT over a Channel with Bit Errors</br></b></p>
                <br>Pada versi ini, disisi Sender ada 2 macam state. Pertama adalah state yang menunggu data untuk dikirimkan. Kedua adalah 
                    state yang menunggu adanya ACK atau NAK yang dikirim dari Receiver. Disisi Reciever, masih menggunakan 1 state saja yaitu hanya 
                    mengirimkan ACK atau NAK tergantung pada paket yang diterima, apakah corrupt atau tidak. rdt2.0 hadir karena Memperbaiki 
                    kelemahan dari rdt 1.0 yaitu dengan adanya checksum untuk mendeteksi bitnya eror atau tidak. rdt2.0 mencoba meniru bagaimana 
                    cara manusia berdialog, yaitu ketika 2 orang sedang berbicara jika yang satunya kurang mengerti akan bertanya ‘maaf kamu tadi 
                    bilang apa? ‘ yang menandakan bahwa dia tidak menangkap pembicaraan.</br>
                <br>Dari Sisi Sender:</br>
                <br>1. Menunggu panggilan dari atas (layer aplikasi)   
                <br>2. Ketika ada perintah maka jalankan fungsi packet=make_pkt(data,checksum) yaitu membuat paket dan menyertakan checksum.  
                <br>3. Packet data dikirimkan lewat udt_send.  
                <br>4. Jika mendapat ACK, berarti packet telah sampai dan tidak corrupt.  
                <br>5. Jika mendapat NAK maka udt_send mentransmisikan ulang yaitu pada fungsi rdt_rcv(rcvpkt)&&is NAK(rcv_pkt) dan udt_send yang mengirimkan file itu lagi.  
                <br>6. Jika mendapat ACK, berarti packet telah sampai dan tidak corrupt.</br>
            </h1>
        </div>
    </section>

    <section id="boxesrrr">
        <div class="container">
            <div class="box">
                <img src="img/rdt2.png">
            </div>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <br>Dari Sisi Receiver:</br>
                <br>1. Fungsi rdt_rcv menunggu panggilan dari bawah(layer data link)  
                <br>2. Ketika ada sinyal maka dia menerima paket dan mengeceknya rusak atau tidak  
                <br>3. Jika tidak maka  selanjutnya akan dijalankan fungsi extract yaitu mengekstrak paket data untuk selanjutnya dikirim ke layer aplikasi(di sisi penerima) dan ia juga mengirim ACK melalui udt_send.  
                <br>4. Jika rusak maka  selanjutnya akan dijalankan fungsi rdt_rcv(rcv_pkt)&& corrupt(rcvpkt) maka udt_send mengirim NAK.  
                <br>5. Lalu rdt_rcv menunggu panggilan dari bawah(layer data link), ketika ada sinyal maka dia menerima paket dan mengeceknya rusak atau tidak, jika tidak maka  selanjutnya akan dijalankan fungsi extract yaitu mengekstrak paket data untuk selanjutnya dikirim ke layer aplikasi(di sisi penerima) dan ia juga mengirim ACK melalui udt_send
            </h1>
        </div>
    </section>

    <section id="boxesrrr">
        <div class="container">
            <div class="box">
                <img src="img/rdt2a.png">
            </div>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <br>Meski terlihat sempurna, namun ada permasalahan dalam proses keseluruhannya. Permasalahannya adalah Sangat fatal yaitu jika 
                    ACK/NAK rusak, Sender tidak tau ACK atau NAK paket yang mana yang diberikan oleh Receiver karena adanya corrupt. karena jika itu 
                    terjadi maka sender tidak tau apa yang terjadi disisi receiver.Untuk mengatasi hal itu, maka ada beberapa pembaruan yang 
                    diterapkan, yaitu sebagai berikut :</br>
                <p><b><br>3. rdt2.1.</b></p>
                <br>Pada versi ini, paket data ditambahkan field yang berisi Sequence Number. Dengan demikian, Reciever hanya perlu memeriksa 
                    isi field tersebut untuk mendefinisikan apakah paket perlu di kirim ulang atau tidak. rdt2.1 Memperbaiki kelemahan rdt 2.0 
                    yaitu dengan menambahkan sequence number pada setiap paket. Carakerjanya samadengan rdt2.0 hanya saja ada 2 paket dan diberikan 
                    sequence number yaitu ‘0’ dan ‘1’.</br>
                <br>Dari Sisi Sender:</br>
                <br>1. Pada state 1 disisi sender menunggu panggilan dari atas (layer aplikasi), ketika ada perintah maka jalankan fungsi packet=make_pkt(0,data,checksum) yaitu membuat paket dan memberi sequence number 0 dan menyertakan checksum  yang akan dikirimkan lewat udt_send.  
                <br>2. Lalu berada pada state ke 2 yaitu menunggu untuk ACK atau NAK dimana ada 2 kemungkinan yaitu jika NAK maka data rusak dan segera kembali mentransmisikan paket 0 melalui udt_send lagi.  
                <br>3. Jika ACK maka paket 0 telah selesai.  
                <br>4. Lalu berada pada state ke 3 yaitu menunggu panggilan dari atas (layer aplikasi) lagi, ketika ada perintah maka jalankan fungsi packet=make_pkt(1,data,checksum) yaitu membuat paket dan memberi sequence number 1 dan menyertakan checksum  yang akan dikirimkan lewat udt_send.  
                <br>5. Lalu berada pada state ke 4 yaitu menunggu untuk ACK atau NAK dimana ada 2 kemungkinan yaitu jika NAK maka data rusak dan segera kembali mentransmisikan paket 1 melalui udt_send lagi.  
                <br>6. Jika ACK maka paket 1 telah selesai. 
            </h1>
        </div>
    </section>

    <section id="boxesrrrr">
        <div class="container">
            <div class="box">
                <img src="img/rdt3.png">
            </div>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <br>Dari Sisi Receiver:</br>
                <br>1. Pada state 1 disisi reveiver rdt_rcv menunggu panggilan 0 dari bawah(layer data link)</br> 
                <br>2. Ketika ada sinyal maka dia menerima paket dan mengeceknya rusak atau tidak, ada 3 kemungkinan yaitu Pertama, jika data 
                    rusak maka receiver menjalankan fungsi rdt_rcv(rcvpkt)&&(corrupt(rcvpkt)) dan mengirimkan paket NAK dengan checksum melalui 
                    udt_send agar disisi sender menerima pemberitahuan paket rusak. kemudian menunggu packet data dengan sequence number 0 untuk 
                    dikirim.</br>  
                <br>3. Kedua, Jika packet data utuh dan packet data diterima dengan sequence no.1, maka receiver mengirimkan packet ACK dan 
                    checksum melalui udt_send. dan kemudian menunggu packet data 0 untuk dikirim.</br>
                <br>4. Ketiga,jika packet data utuh dan packet data yang dikirim adalah packet data 0 maka menjalankan fungsi 
                    rdt_rcv(rcvpkt)&&(not corrupt(rcvpkt)) || has_seq0 dan mengirimkan paket ACK dengan checksum melalui udt_send agar disisi 
                    sender menerima pemberitahuan paket sampai dan tidak rusak.</br> 
                <br>5. Jika paket utuh dan  tidak eror maka  selanjutnya akan dijalankan fungsi extract yaitu mengekstrak paket data dengan seq 
                    0 untuk selanjutnya dikirim ke layer aplikasi(di sisi penerima).</br>
                <br>6. Pada state ke2 yaitu menunggu panggilan 1 dari bawah(layer data link)</br>  
                <br>7. Ketika ada sinyal maka dia menerima paket dan mengeceknya rusak atau tidak, ada 3 kemungkinan yaitu jika data rusak maka 
                    menjalankan fungsi rdt_rcv(rcvpkt)&&(corrupt(rcvpkt)) dan mengirimkan paket NAK dengan checksum melalui udt_send agar disisi sender 
                    menerima pemberitahuan paket rusak.</br> 
                <br>8. Kedua, Jika packet data utuh dan packet data diterima dengan sequence no.0, maka receiver memberikan ACK. kemudian 
                    receiver mengirimkan packet ACK dan checksum melalui udt_send. dan kemudian menunggu packet data 1 untuk dikirim.</br>
                <br>9. Ketiga,packet data utuh dan packet data yang dikirim adalah packet data 1 maka menjalankan fungsi 
                    rdt_rcv(rcvpkt)&&(not corrupt(rcvpkt)) || has_seq1 dan mengirimkan paket ACK dengan checksum melalui udt_send agar disisi sender 
                    menerima pemberitahuan paket sampai dan tidak rusak.</br>
            </h1>
        </div>
    </section>

    <section id="boxesrrrr">
        <div class="container">
            <div class="box">
                <img src="img/rdt3a.png">
            </div>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <p><b><br>4. rdt2.2.</p></b>
                <br>Pada versi ini menangani jika ACK yang diterima adalah ACK untuk paket yang sama (duplicate ACK). Duplicate ACK terjadi 
                    karena pada versi ini NAK dihilangkan (mengabaikan NAK). Dengan demikian, jika seandainya ACK yang diterima mengalami duplikasi, 
                    maka paket tersebut akan dikirim ulang.</br>
                <br>Dari Sisi Sender:</br>
                <br>1. Pada state 1 menunggu panggilan dari atas (layer aplikasi) ketika ada perintah maka jalankan fungsi 
                    packet=make_pkt(0,data,checksum) yaitu membuat paket dan memberi sequence number 0 dan menyertakan checksum  yang akan 
                    dikirimkan lewat udt_send.</br>  
                <br>2. Lalu berada pada state ke 2 yaitu menunggu untuk ACK 0 dimana ada 2 kemungkinan yaitu jika menerima packet data rusak 
                    atau ACK 1 maka packet data kembali mentransmisikan paket 0 melalui udt_send lagi.</br>
                <br>3. Jika packet data tidak rusak dan menerima  ACK 0 maka sudah benar dan  telah selesai.</br> 
                <br>4. Berlanjut Pada state 3 yaitu menunggu panggilan dari atas (layer aplikasi) ketika ada perintah maka jalankan fungsi 
                    packet=make_pkt(1,data,checksum) yaitu membuat paket dan memberi sequence number 1 dan menyertakan checksum  yang akan 
                    dikirimkan lewat udt_send.</br> 
                <br>5. Lalu berada pada state ke 4 yaitu menunggu untuk ACK 1 dimana ada 2 kemungkinan yaitu jika menerima packet data rusak atau 
                    ACK 0 maka packet data kembali mentransmisikan paket 1 melalui udt_send lagi.</br>
                <br>6. Jika packet data tidak rusak dan menerima  ACK 1 maka sudah benar dan  telah selesai.</br>
            </h1>
        </div>
    </section>

    <section id="boxesrrrr">
        <div class="container">
            <div class="box">
                <img src="img/rdt4.png">
            </div>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <br>Dari Sisi Receiver :</br>
                <br>1. Pada state 1 disisi reveiver rdt_rcv menunggu panggilan packet data 0 dari bawah(layer data link), ketika ada sinyal 
                    maka dia menerima paket dan mengeceknya rusak atau tidak, ada 2 kemungkinan yaitu jika data corrupt atau packet data yang 
                    diterima adalah packet data sequence no.1,maka receiver akan mengirimkan ACK 1 dengan menjalankan fungsi udt_send(snd_pkt) 
                    kemudian menunggu kembali untuk packet data 0 untuk dikirim.</br> 
                <br>2. Jika data utuh dan memiliki sequence no.0 maka menjalankan fungsi rdt_rcv(rcvpkt)&&(not corrupt(rcvpkt)) || 
                    has_seq0(rcvpkt)  lalu menjalankan fungsi extract yaitu mengekstrak paket data untuk selanjutnya dikirim ke layer 
                    aplikasi(di sisi penerima). Receiver juga mengirimkan paket ACK 0 dengan checksum melalui udt_send agar disisi sender menerima 
                    pemberitahuan paket sampai dan tidak rusak.</br> 
                <br>3. Pada state 2 disisi reveiver rdt_rcv menunggu panggilan packet data 1 dari bawah(layer data link), ketika ada sinyal 
                    maka dia menerima paket dan mengeceknya rusak atau tidak, ada 2 kemungkinan yaitu jika data corrupt atau packet data yang 
                    diterima adalah packet data sequence no.0,maka receiver akan mengirimkan ACK 0 dengan menjalankan fungsi udt_send(snd_pkt) 
                    kemudian menunggu kembali untuk packet data 1 untuk dikirim.</br>
                <br>4. Jika data utuh dan memiliki sequence no.0, maka menjalankan fungsi rdt_rcv(rcvpkt)&&(not corrupt(rcvpkt)) || 
                    has_seq1(rcvpkt)  lalu menjalankan fungsi extract yaitu mengekstrak paket data untuk selanjutnya dikirim ke layer 
                    aplikasi(di sisi penerima). Receiver juga mengirimkan paket ACK 1 dengan checksum melalui udt_send agar disisi sender menerima 
                    pemberitahuan paket sampai dan tidak rusak.</br> 
            </h1>
        </div>
    </section>

    <section id="boxesrrrr">
        <div class="container">
            <div class="box">
                <img src="img/rdt4a.png">
            </div>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <p><b><br>5. rdt3.0 = RDT over a Lossy Channel with Bit Errors</p></b>
                <br>Pada versi ini, Sender dilengkapi dengan timer untuk ACK. Cara kerjanya adalah jika ACK tidak tiba, maka paket tersebut akan 
                    dikirim ulang. Jika seandainya ACK tidak hilang, namun hanya terkena delay, maka hal ini akan menyebabkan paket terduplikasi. Namun, 
                    karena adanya field untuk sequence number , maka paket tidak perlu diteruskan ke lapisan aplikasi.</br>
                <br>Dari Sisi Sender:</br>
                <br>1. Pada state 1 menunggu panggilan dari atas (layer aplikasi) ketika ada perintah maka akan terjadi 2 kemungkinan. pertama, 
                    jalankan fungsi packet=make_pkt(0,data,checksum) yaitu membuat paket dan memberi sequence number 0 dan menyertakan checksum  yang akan 
                    dikirimkan lewat udt_send dan diberikan timer.</br> 
                <br>2. Kedua, dari sisi sender akan menerima packet melalui fungsi rdt_rcv(rcvpkt).</br> 
                <br>3. Pada state ke 2 yaitu menunggu untuk ACK 0 dimana ada 3 kemungkinan yaitu pertama jika packet data yang diterima rusak 
                    atau medapatkan ACK 1, maka langsung menunggu Kembali ACK 0 dari sisi penerima.  
                <br>4. Kedua, jika kehabisan waktu(timeout), maka packet data 0 akan dikirim ulang dan memulai ulang waktu Kembali.</br> 
                <br>5. Ketiga, Jika packet data yang diterima tidak rusak dan mendapatkan ACK 0, maka hentikan waktunya. artinya packet data 0 
                    sudah sampai di penerima.</br> 
                <br>6. Pada state 3 yaitu  menunggu panggilan dari atas (layer aplikasi) ketika ada perintah maka akan terjadi 2 kemungkinan. 
                    Pertama, jalankan fungsi packet=make_pkt(1,data,checksum) yaitu membuat paket dan memberi sequence number 1 dan menyertakan 
                    checksum  yang akan dikirimkan lewat udt_send dan diberikan timer.</br> 
                <br>7. Pada state ke 4 yaitu menunggu untuk ACK 1 dimana ada 3 kemungkinan yaitu pertama jika packet data yang diterima rusak atau 
                    mendapatkan ACK 0, maka langsung menunggu Kembali ACK 1 dari sisi penerima.</br>
                <br>8. Kedua, jika kehabisan waktu(timeout), maka packet data 1 akan dikirim ulang dan memulai ulang waktu Kembali.</br>  
                <br>9. Ketiga, Jika packet data yang diterima tidak rusak dan mendapatkan ACK 1, maka hentikan waktunya. artinya packet data 1 
                    sudah sampai di penerima.
            </h1>
        </div>
    </section>

    <section id="boxesrrrr">
        <div class="container">
            <div class="box">
                <img src="img/rdt5.png">
            </div>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <br>Dari Sisi Receiver:</br>
                <br>1. Pada state 1 disisi reveiver rdt_rcv menunggu panggilan packet data 0 dari bawah(layer data link), ketika ada sinyal 
                    maka dia menerima paket dan mengeceknya rusak atau tidak, ada 2 kemungkinan yaitu jika data corrupt atau packet data yang 
                    diterima adalah packet data sequence no.1,maka receiver akan mengirimkan ACK 1 dengan menjalankan fungsi udt_send(snd_pkt) 
                    kemudian menunggu kembali untuk packet data 0 untuk dikirim.</br> 
                <br>2. Jika data utuh dan memiliki sequence no.0 maka menjalankan fungsi rdt_rcv(rcvpkt)&&(not corrupt(rcvpkt)) || 
                    has_seq0(rcvpkt)  lalu menjalankan fungsi extract yaitu mengekstrak paket data untuk selanjutnya dikirim ke layer 
                    aplikasi(di sisi penerima). Receiver juga mengirimkan paket ACK 0 dengan checksum melalui udt_send agar disisi sender 
                    menerima pemberitahuan paket sampai dan tidak rusak.</br> 
                <br>3. Pada state 2 disisi reveiver rdt_rcv menunggu panggilan packet data 1 dari bawah(layer data link), ketika ada sinyal 
                    maka dia menerima paket dan mengeceknya rusak atau tidak, ada 2 kemungkinan yaitu jika data corrupt atau packet data yang 
                    diterima adalah packet data sequence no.0,maka receiver akan mengirimkan ACK 0 dengan menjalankan fungsi udt_send(snd_pkt) 
                    kemudian menunggu kembali untuk packet data 1 untuk dikirim.</br>  
                <br>4. Jika data utuh dan memiliki sequence no.0, maka menjalankan fungsi rdt_rcv(rcvpkt)&&(not corrupt(rcvpkt)) || 
                    has_seq1(rcvpkt)  lalu menjalankan fungsi extract yaitu mengekstrak paket data untuk selanjutnya dikirim ke layer 
                    aplikasi(di sisi penerima). Receiver juga mengirimkan paket ACK 1 dengan checksum melalui udt_send agar disisi sender 
                    menerima pemberitahuan paket sampai dan tidak rusak. 
            </h1>
        </div>
    </section>

    <section id="boxesrrrr">
        <div class="container">
            <div class="box">
                <img src="img/rdt5a.png">
            </div>
        </div>
    </section>

    <section id="letterr">
        <div class: "container">
            <h1>
                <br>Implementasi FSM rdt3.0 adalah sama dengan rdt2.2, dikarenakan rdt 2.2 FSM receiver bisa menghandle packet data yang hilang 
                    (loss). misalnya jika dari sisi pengirim mengirim packet data 0, yang datang malah packet data 1. itu artinya packet data 0 
                    tersebut hilang (loss). dengan implementasi FSM pada rdt2.2 itu, maka dari sisi receiver akan  mengirimkan berupa ACK 1 untuk 
                    packet data 1,kemudian menunggu Kembali hingga si pengirim mengirimkan packet data 0 lagi. Jika sudah mendapatkan packet data 0, 
                    maka dari sisi penerima akan mengirimkan balasan berupa ACK 0 kemudian packet data itu di dekapsulasi kemudian di serahkan ke layer 
                    paling atas (application layer).</br>
            </h1>
        </div>
    </section>




    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

</body>

</html>
